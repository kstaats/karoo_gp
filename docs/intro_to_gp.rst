===================================
Introduction to Genetic Programming
===================================

What is Genetic Programming?
============================

Genetic Programming (GP) is a type of evolutionary computation, a subset of
machine learning. Inspired by biological evolution, GP uses random mutation,
crossover, a fitness function, and multiple generations of evolution of a
population of computer programs to resolve a user-defined task. At the
foundation level, GP discovers relationships between data features—correlations
between measurements of the real world.

Long before the advent of gene sequencing or machine learning, taxonomists
conducted precise measurements of physical plants and animals in order to
differentiate species. In 1936, biologist R.A. Fisher worked to differentiate
species of Iris flowers using data generated by Edgar Anderson. In his paper
“The use of multiple measurements in taxonomic problems”, Fisher states “When
two or more populations have been measured in several characters, xl, ..., x8,
special interest attaches to certain linear functions of the measurements by
which the populations are best discriminated.” Using Genetic Programming, we
readily discover the mathematical expressions that cleanly separate the three
Iris species using just 50 data points each. This Iris multivariate dataset is
a simple yet classic, must-solve problem for all Machine Learning developers
of classification algorithms, and is included with Karoo GP as the default
Classification dataset.

In general, genetic programming can be used to discover a relationship between
features in data (symbolic regression) or to group data into categories
(classification). Both of these employ a training (learning) and test
(validation) phase, after which the resulting function (mathematical
expression) may be employed in a live data stream for realtime regression or
classification analysis, accordingly.

GP Parameters
=============

1. Tree Type
------------
All Full tree branches reach the maximum depth. These trees are less likely
to solve problems as they are not as flexible in their solution space. For
example, if the desired solution is ``a + b + c`` (5 elements) but the Full tree
is confined to 15 elements, some will be forced to cancel each other in order
to arrive to the desired solution. However, Full trees do contribute higher
order expressions.

Grow trees have unbalanced branches, meaning some branches reach the maximum
depth while others do not. Grow trees are more likely to find simpler
solutions, but may not discover improved solutions in a higher order space.

Originated by John Koza, Ramped Half/Half initialises the first population with
a 50/50 split of Full/Grow methods, and a spread of depths from min to max. The
Grow method is then applied for each subsequent population. This is the most
popular method as it injects a higher degree of diversity into the initial
population.

2. Base Tree Depth
------------------

.. figure:: /_static/karoo_depth.png
   :scale: 40%
   :align: right

This is the tree depth for the initial population. By default, this is also the
Maximum Tree Depth (below), unless otherwise user specified. If the base and
maximum tree depths are equal, this will inhibit bloat, but also restrict
potential, more complex solutions.

The depth of a tree is illustrated to the right, and relates to the maximum
possible number of nodes, as follows:

.. math::

    nodes = 2^{(depth+1)} – 1

3. Maximum Tree Depth
---------------------
Karoo is unique from traditional tree-based GP in that it incorporates a user
defined maximum tree depth, thereby restricting program bloat. However, deeper
trees present opportunity for more complex solutions, and they enable the
inclusion of a greater number of features (columns in your ``.csv``). As depth 3
enables up to 15 nodes, and depth 5 enables up to 63 nodes, quite a bit of
growth is possible with trees just 2-3 depths greater. Or, you can set the
maximum to 10 (2047 possible nodes) and learn if a larger solution is in fact
more able to resolve your data.

4. Minimum Number of Nodes
--------------------------
If the Maximum Tree Depth is the ceiling, then this is the floor. The minimum
number of nodes (both operators and terminals) defines the simplest expression
allowed. For example, the correct solution to Kepler's 3rd Law of Planetary
Motion is ``t * t / r * r * r`` which has 9 elements (nodes). In Karoo GP, the gene
pool from which the tournament selection operates is built only from those
trees which meet the minimum number of nodes criterion. This is very useful in
solving the default problem for the Regression kernel, as GP tends to the
simpler ``t / t``.

.. note::
   If you set the minimum number of nodes too high, you may invoke
   elitism in the population, killing off simpler solutions or even the entire
   population.

5. Number of Trees
------------------
100 trees per population is a good place to start. However, larger populations
offer a greater diversity of possible solutions. Feel free to experiment with
larger populations.

6. Number of Generations
------------------------
For simpler problems with less than a dozen features, 10 generations will often
give you a sense of whether or not Karoo GP is on the right track. With more
complex problems, 20, 30, ... 50 or more generations may be required for the
random process of evolution to generate an improved tree which provides the
desired solution.

You may (cont)inue with subsequent generations when all generations have run
their course (see bottom).

The Evolutionary Operators
==========================
There are 4 evolutionary operators applied in Karoo GP. The foundation for
these evolutionary operators was derived from the “Field Guide to Genetic
Programming” * by Riccardo Poli, William Langdon, and Nicholas McPhee, with
contributions by John Koza. Using the (b)alance option in the pause menu,
you can set the ratio of the operators, such that combined they equal 100%.

In the following, tournament selection refers to the random selection of a
number of trees (default 10) whose fitness scores are compared. The tree with
the highest score is moved to the next generation through an evolutionary
operation. We use tournament selection, not a top-to-bottom evaluation of the
entire population, else we risk elitism, premature convergence on what may not
be the best overall solution.

Reproduction
------------

.. figure:: /_static/karoo_repro.png
   :scale: 60%
   :align: right

Through tournament selection, a single tree from the prior population is copied
without mutation to the next generation. In the biological world, this is
analogous to a member of a population entering the gene pool of the subsequent
(younger) generation.

Point Mutation
--------------

.. figure:: /_static/karoo_point_mut.png
   :scale: 60%
   :align: right

Through tournament selection, a copy of a tree from the prior population
mutates a single node before being added to the next generation. In the
biological world, this may be analogous to asexual reproduction, that is,
a copy of an individual with a minor mutation. In this method, a single
point is selected for mutation while maintaining function nodes as operators
and terminal nodes as terminals. The size and shape of the tree will remain
identical.

Branch Mutation
---------------

.. figure:: /_static/karoo_branch_mut.png
   :scale: 60%
   :align: right

Through tournament selection, a copy of a tree from the prior population
mutates before being added to the next generation. In the biological world,
this may be analogous to asexual reproduction, that is, a copy of an individual
but with a potentially substantial mutation. Unlike Point Mutation, in this
method an entire branch is selected. If the evolutionary run is designated as
Full, the size and shape of the tree will remain identical, each node mutated
sequentially, where functions remain functions and terminals remain terminals.
If the evolutionary run is designated as Grow or Ramped Half/Half, the size and
shape of the tree may grow smaller or larger, but it may not exceed the maximum
depth defined by the user.

Crossover
---------

.. figure:: /_static/karoo_cross.png
   :scale: 60%
   :align: right

Through tournament selection, 2 trees are selected as parents to produce 2
offspring. Within each parent tree a branch is selected. For child A, parent
A is copied, with its selected branch deleted. Parent B's branch is then copied
to the former location of parent A's branch, and inserted (grafted). This is
reversed for child B. The size and shape of the offspring may be smaller or
larger than either of the parents, but may not exceed the maximum depth defined
by the user.

This process combines genetic code from trees which were chosen by the
tournament process as having a higher fitness than the average population.
Therefore, there is a higher probability their offspring will provide an
improved fitness.

According to the literature, crossover is the most commonly applied
evolutionary operator at 70-90%.
